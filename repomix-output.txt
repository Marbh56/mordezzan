This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-16T23:50:56.826Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cmd/
  web/
    handlers.go
    helpers.go
    main.go
    routes.go
    templates.go
internal/
  db/
    db.go
    models.go
    users.sql.go
  models/
    db.go
    password.go
    users.go
sql/
  queries/
    users.sql
  schema/
    001_initial.sql
ui/
  html/
    pages/
      base.tmpl
      home.tmpl
      registration.tmpl
.gitignore
go.mod
go.sum
LICENSE
LICENSE.OGL
README.md
sqlc.yaml

================================================================
Files
================================================================

================
File: cmd/web/handlers.go
================
package main

import (
	"fmt"
	"net/http"

	"github.com/marbh56/mordezzan/internal/db"
)

func (app *application) home(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	tmpl, ok := app.templateCache["home.tmpl"]
	if !ok {
		app.serverError(w, fmt.Errorf("the template %s does not exist", "home.tmpl"))
		return
	}

	err := tmpl.ExecuteTemplate(w, "base", nil)
	if err != nil {
		app.serverError(w, err)
	}
}

func (app *application) registerForm(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		w.Header().Set("Allow", http.MethodGet)
		app.clientError(w, http.StatusMethodNotAllowed)
		return
	}

	tmpl, ok := app.templateCache["register.tmpl"]
	if !ok {
		app.serverError(w, fmt.Errorf("the template %s does not exist", "register.tmpl"))
		return
	}

	err := tmpl.ExecuteTemplate(w, "base", nil)
	if err != nil {
		app.serverError(w, err)
	}
}

func (app *application) register(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.Header().Set("Allow", http.MethodPost)
		app.clientError(w, http.StatusMethodNotAllowed)
		return
	}

	err := r.ParseForm()
	if err != nil {
		app.clientError(w, http.StatusBadRequest)
		return
	}

	_, err = app.models.Users.CreateUser(r.Context(), db.CreateUserParams{
		Name:         name,
		Email:        email,
		PasswordHash: hashedPassword,
	})

	if err != nil {
		app.serverError(w, err)
		return
	}

	http.Redirect(w, r, "/login", http.StatusSeeOther)
}

================
File: cmd/web/helpers.go
================
package main

import (
	"fmt"
	"net/http"
	"runtime/debug"
)

func (app *application) serverError(w http.ResponseWriter, err error) {
    trace := fmt.Sprintf("%s\n%s", err.Error(), debug.Stack())
    app.errorLog.Output(2, trace)

    http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
}

func (app *application) clientError(w http.ResponseWriter, status int) {
    http.Error(w, http.StatusText(status), status)
}

func (app *application) notFound(w http.ResponseWriter) {
    app.clientError(w, http.StatusNotFound)
}

================
File: cmd/web/main.go
================
package main

import (
	"database/sql"
	"html/template"
	"log"
	"net/http"
	"os"

	"github.com/marbh56/mordezzan/internal/models"
	_ "github.com/mattn/go-sqlite3"
)

type application struct {
	errorLog      *log.Logger
	infoLog       *log.Logger
	templateCache map[string]*template.Template
	models        models.Models
}

func main() {
	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
	errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)

	db, err := sql.Open("sqlite3", "./data.db")
	if err != nil {
		errorLog.Fatal(err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		errorLog.Fatal(err)
	}

	templateCache, err := newTemplateCache()
	if err != nil {
		errorLog.Fatal(err)
	}

	app := &application{
		errorLog:      errorLog,
		infoLog:       infoLog,
		templateCache: templateCache,
		models:        models.NewModels(db),
	}

	srv := &http.Server{
		Addr:     ":4000",
		Handler:  app.routes(),
		ErrorLog: errorLog,
	}

	infoLog.Printf("Starting server on :4000")
	err = srv.ListenAndServe()
	errorLog.Fatal(err)
}

================
File: cmd/web/routes.go
================
package main

import (
	"net/http"
)

func (app *application) routes() http.Handler {
	mux := http.NewServeMux()

	mux.HandleFunc("/", app.home)
	mux.HandleFunc("/register", app.registerForm)
	mux.HandleFunc("/register", app.register)

	return mux
}

================
File: cmd/web/templates.go
================
package main

import (
	"html/template"
	"path/filepath"
)

func newTemplateCache() (map[string]*template.Template, error) {
    cache := map[string]*template.Template{}

    pages, err := filepath.Glob("./ui/html/pages/*.tmpl")
    if err != nil {
        return nil, err
    }

    for _, page := range pages {
        name := filepath.Base(page)

        ts, err := template.ParseFiles("./ui/html/pages/base.tmpl")
        if err != nil {
            return nil, err
        }

        ts, err = ts.ParseFiles(page)
        if err != nil {
            return nil, err
        }

        cache[name] = ts
    }

    return cache, nil
}

================
File: internal/db/db.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

================
File: internal/db/models.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package db

import (
	"time"
)

type User struct {
	ID           int64     `json:"id"`
	Name         string    `json:"name"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
	CreatedAt    time.Time `json:"created_at"`
}

================
File: internal/db/users.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package db

import (
	"context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (name, email, password_hash)
VALUES
    (?, ?, ?) RETURNING id, name, email, password_hash, created_at
`

type CreateUserParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE
    id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUser = `-- name: GetUser :one
SELECT
    id, name, email, password_hash, created_at
FROM
    users
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    id, name, email, password_hash, created_at
FROM
    users
WHERE
    email = ?
LIMIT
    1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT
    id, name, email, password_hash, created_at
FROM
    users
ORDER BY
    name
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.PasswordHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    name = ?,
    email = ?
WHERE
    id = ? RETURNING id, name, email, password_hash, created_at
`

type UpdateUserParams struct {
	Name  string `json:"name"`
	Email string `json:"email"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser, arg.Name, arg.Email, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

================
File: internal/models/db.go
================
package models

import (
	"database/sql"

	_ "github.com/mattn/go-sqlite3" // SQLite driver
)

type Models struct {
    // We'll add more models here as we create them
    Users UserModel
}

func NewModels(db *sql.DB) Models {
    return Models{
        Users: UserModel{DB: db},
    }
}

================
File: internal/models/password.go
================
package models

import (
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
    hash, err := bcrypt.GenerateFromPassword([]byte(password), 12)
    if err != nil {
        return "", err
    }
    return string(hash), nil
}

func CheckPassword(hash, password string) error {
    return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}

================
File: internal/models/users.go
================
package models

import "database/sql"


type UserModel struct {
	DB *sql.DB
}

================
File: sql/queries/users.sql
================
-- name: CreateUser :one
INSERT INTO
    users (name, email, password_hash)
VALUES
    (?, ?, ?) RETURNING *;

-- name: GetUser :one
SELECT
    *
FROM
    users
WHERE
    id = ?
LIMIT
    1;

-- name: GetUserByEmail :one
SELECT
    *
FROM
    users
WHERE
    email = ?
LIMIT
    1;

-- name: ListUsers :many
SELECT
    *
FROM
    users
ORDER BY
    name;

-- name: UpdateUser :one
UPDATE users
SET
    name = ?,
    email = ?
WHERE
    id = ? RETURNING *;

-- name: DeleteUser :exec
DELETE FROM users
WHERE
    id = ?;

================
File: sql/schema/001_initial.sql
================
-- +goose Up
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL, -- Store the hashed password, never the plain text
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- +goose Down
DROP TABLE IF EXISTS users;

================
File: ui/html/pages/base.tmpl
================
{{define "base"}}
<!doctype html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <title>{{template "title" .}} - Your Site</title>
        <!-- We'll add more head elements later -->
    </head>
    <body>
        <header>
            <h1>Your Site</h1>
        </header>
        <main>
            {{template "main" .}}
        </main>
        <footer>Powered by Go</footer>
    </body>
</html>
{{end}}

================
File: ui/html/pages/home.tmpl
================
{{define "title"}}Home{{end}}

{{define "main"}}
    <h2>Welcome</h2>
    <p>Welcome to our new website!</p>
{{end}}

================
File: ui/html/pages/registration.tmpl
================
{{define "title"}}Register{{end}}

{{define "main"}}
<form action="/register" method="POST">
    <div>
        <label for="name">Name:</label>
        <input type="text" name="name" id="name" required>
    </div>
    <div>
        <label for="email">Email:</label>
        <input type="email" name="email" id="email" required>
    </div>
    <div>
        <label for="password">Password:</label>
        <input type="password" name="password" id="password" required>
    </div>
    <div>
        <label for="confirm-password">Confirm Password:</label>
        <input type="password" name="confirm-password" id="confirm-password" required>
    </div>
    <div>
        <input type="submit" value="Register">
    </div>
</form>
{{end}}

================
File: .gitignore
================
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

================
File: go.mod
================
module github.com/marbh56/mordezzan

go 1.23.3

require (
	github.com/mattn/go-sqlite3 v1.14.24
	golang.org/x/crypto v0.32.0
)

================
File: go.sum
================
github.com/mattn/go-sqlite3 v1.14.24 h1:tpSp2G2KyMnnQu99ngJ47EIkWVmliIizyZBfPrBWDRM=
github.com/mattn/go-sqlite3 v1.14.24/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
golang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=
golang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=

================
File: LICENSE
================
MIT License

Copyright (c) 2023 Asacolips Projects / Foundry Mods

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

This license does not apply to the compendium content listed in this software's
"packs" directory. See the README for licensing information for the compendium
packs.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: LICENSE.OGL
================
OPEN GAME LICENSE Version 1.0a

The following text is the property of Wizards of the Coast, Inc. and is
Copyright 2000 Wizards of the Coast, Inc ("Wizards"). All Rights Reserved.

1. Definitions: (a) "Contributors" means the copyright and/or trademark owners
who have contributed Open Game Content; (b) "Derivative Material" means
copyrighted material including derivative works and translations (including into
other computer languages), potation, modification, correction, addition,
extension, upgrade, improvement, compilation, abridgment or other form in which
an existing work may be recast, transformed or adapted; (c) "Distribute" means
to reproduce, license, rent, lease, sell, broadcast, publicly display, transmit
or otherwise distribute; (d) "Open Game Content" means the game mechanic and
includes the methods, procedures, processes and routines to the extent such
content does not embody the Product Identity and is an enhancement over the
prior art and any additional content clearly identified as Open Game Content by
the Contributor, and means any work covered by this License, including
translations and derivative works under copyright law, but specifically excludes
Product Identity; (e) "Product Identity" means product and product line names,
logos and identifying marks including trade dress; artifacts; creatures;
characters; stories, storylines, plots, thematic elements, dialogue, incidents,
language, artwork, symbols, designs, depictions, likenesses, formats, poses,
concepts, themes and graphic, photographic and other visual or audio
representations; names and descriptions of characters, spells, enchantments,
personalities, teams, personas, likenesses and special abilities; places,
locations, environments, creatures, equipment, magical or supernatural abilities
or effects, logos, symbols, or graphic designs; and any other trademark or
registered trademark clearly identified as Product Identity by the owner of the
Product Identity, and which specifically excludes the Open Game Content; (f)
"Trademark" means the logos, names, mark, sign, motto, designs that are used by
a Contributor to identify itself or its products or the associated products
contributed to the Open Game License by the Contributor; (g) "Use", "Used" or
"Using" means to use, Distribute, copy, edit, format, modify, translate and
otherwise create Derivative Material of Open Game Content; (h) "You" or "Your"
means the licensee in terms of this agreement.

2. The License: This License applies to any Open Game Content that contains a
notice indicating that the Open Game Content may only be Used under and in terms
of this License. You must affix such a notice to any Open Game Content that You
Use. No terms may be added to or subtracted from this License except as
described by the License itself. No other terms or conditions may be applied to
any Open Game Content Distributed using this License.

3. Offer and Acceptance: By Using the Open Game Content You indicate Your
acceptance of the terms of this License.

4. Grant and Consideration: In consideration for agreeing to use this License,
the Contributors grant You a perpetual, worldwide, royalty-free, non-exclusive
license with the exact terms of this License to Use, the Open Game Content.

5. Representation of Authority to Contribute: If You are contributing original
material as Open Game Content, You represent that Your contributions are Your
original creation and/or You have sufficient rights to grant the rights conveyed
by this License.

6. Notice of License Copyright: You must update the COPYRIGHT NOTICE portion of
this License to include the exact text of the COPYRIGHT NOTICE of any Open Game
Content You are copying, modifying or Distributing, and You must add the title,
the copyright date, and the copyright holder's name to the COPYRIGHT NOTICE of
any original Open Game Content You Distribute.

7. Use of Product Identity: You agree not to Use any Product Identity, including
as an indication as to compatibility, except as expressly licensed in another,
independent agreement with the owner of each element of that Product Identity.
You agree not to indicate compatibility or co-adaptability with any Trademark or
registered Trademark in conjunction with a work containing Open Game Content
except as expressly licensed in another, independent agreement with the owner of
such Trademark or registered Trademark. The Use of any Product Identity in Open
Game Content does not constitute a challenge to the ownership of that Product
Identity. The owner of any Product Identity Used in Open Game Content shall
retain all rights, title and interest in and to that Product Identity.

8. Identification: If You Distribute Open Game Content You must clearly indicate
which portions of the work that You are Distributing are Open Game Content.

9. Updating the License: Wizards or its designated Agents may publish updated
versions of this License. You may use any authorized version of this License to
copy, modify and Distribute any Open Game Content originally Distributed under
any version of this License.

10. Copy of this License: You MUST include a copy of this License with every
copy of the Open Game Content You Distribute.

11. Use of Contributor Credits: You may not market or advertise the Open Game
Content using the name of any Contributor unless You have written permission
from the Contributor to do so.

12. Inability to Comply: If it is impossible for You to comply with any of the
terms of this License with respect to some or all of the Open Game Content due
to statute, judicial order, or governmental regulation then You may not Use any
Open Game Material so affected.

13. Termination: This License will terminate automatically if You fail to comply
with all terms herein and fail to cure such breach within 30 days of becoming
aware of the breach. All sublicenses shall survive the termination of this
License.

14. Reformation: If any provision of this License is held to be unenforceable,
such provision shall be reformed only to the extent necessary to make it
enforceable.

15. COPYRIGHT NOTICE
Open Game License v 1.0a Copyright 2000, Wizards of the Coast, Inc.

System Reference Document © 2000, Wizards of the Coast, Inc.; Authors Jonathan Tweet, Monte Cook, Skip Williams, based on original material by E. Gary Gygax and Dave Arneson.

System Reference Document © 2000-2003, Wizards of the Coast, Inc.; Authors Jonathan Tweet, Monte Cook, Skip Williams, Rich Baker, Andy Collins, David Noonan, Rich Redman, Bruce R. Cordell, John D. Rateliff, Thomas Reid, James Wyatt, based on original material by E. Gary Gygax and Dave Arneson.

Modern System Reference Document © 2002-2004, Wizards of the Coast, Inc.; Authors Bill Slavicsek, Jeff Grubb, Rich Redman, Charles Ryan, Eric Cagle, David Noonan, Stan!, Christopher Perkins, Rodney Thompson, and JD Wiker, based on material by Jonathan Tweet, Monte Cook, Skip Williams, Richard Baker, Peter Adkison, Bruce R. Cordell, John Tynes, Andy Collins, and JD Wiker.

Castles & Crusades: Players Handbook, © 2004, Troll Lord Games; Authors Davis Chenault and Mac Golden.

Cave Cricket from the Tome of Horrors, © 2002, Necromancer Games, Inc.; Authors Scott Greene and Clark Peterson, based on original material by Gary Gygax.

Crab, Monstrous from the Tome of Horrors, © 2002, Necromancer Games, Inc.; Author Scott Greene, based on original material by Gary Gygax.

Fly, Giant from the Tome of Horrors, © 2002, Necromancer Games, Inc.; Author Scott Greene, based on original material by Gary Gygax.

Golem, Wood from the Tome of Horrors, © 2002, Necromancer Games, Inc.; Authors Scott Greene and Patrick Lawinger.

Kamadan from the Tome of Horrors, © 2002, Necromancer Games, Inc.; Author Scott Greene, based on original material by Nick Louth.

Rot Grub from the Tome of Horrors, © 2002, Necromancer Games, Inc.; Authors Scott Greene and Clark Peterson, based on original material by Gary Gygax.

Labyrinth Lord™ © 2007-2009, Daniel Proctor. Author Daniel Proctor.

B/X Essentials: Core Rules © 2017 Gavin Norman. Author Gavin Norman.

B/X Essentials: Classes and Equipment © 2017 Gavin Norman. Author Gavin Norman.

B/X Essentials: Cleric and Magic-User Spells © 2017 Gavin Norman. Author Gavin Norman.

B/X Essentials: Monsters © 2017 Gavin Norman. Author Gavin Norman.

B/X Essentials: Adventures and Treasures © 2018 Gavin Norman. Author Gavin Norman.

Old-School Essentials Core Rules © 2018 Gavin Norman.

Old-School Essentials Classic Fantasy: Genre Rules © 2018 Gavin Norman.

Old-School Essentials Classic Fantasy: Cleric and Magic-User Spells © 2018 Gavin Norman.

Old-School Essentials Classic Fantasy: Monsters © 2018 Gavin Norman.

Old-School Essentials Classic Fantasy: Treaures © 2018 Gavin Norman.

Old-School Essentials Classic Fantasy: Rules Tome © 2019 Gavin Norman.

Old-School Essentials System Reference Document © 2019 Gavin Norman. Author Gavin Norman.

Old School Essentials OGL Content for Foundry VTT © 2020 Emmanuel Ruaud.

================
File: README.md
================
# mordezzan

================
File: sqlc.yaml
================
version: "2"
sql:
  - engine: "sqlite"
    queries: "./sql/queries/"
    schema: "./sql/schema/"
    gen:
      go:
        package: "db"
        out: "internal/db"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: false
        emit_exact_table_names: false
