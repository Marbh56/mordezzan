// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: inventory.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addItemToInventory = `-- name: AddItemToInventory :one
INSERT INTO
    character_inventory (
        character_id,
        item_type,
        item_id,
        quantity,
        container_inventory_id,
        equipment_slot_id,
        notes
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?) RETURNING id, character_id, item_type, item_id, quantity, container_inventory_id, equipment_slot_id, notes, created_at, updated_at
`

type AddItemToInventoryParams struct {
	CharacterID          int64          `json:"character_id"`
	ItemType             string         `json:"item_type"`
	ItemID               int64          `json:"item_id"`
	Quantity             int64          `json:"quantity"`
	ContainerInventoryID sql.NullInt64  `json:"container_inventory_id"`
	EquipmentSlotID      sql.NullInt64  `json:"equipment_slot_id"`
	Notes                sql.NullString `json:"notes"`
}

func (q *Queries) AddItemToInventory(ctx context.Context, arg AddItemToInventoryParams) (CharacterInventory, error) {
	row := q.db.QueryRowContext(ctx, addItemToInventory,
		arg.CharacterID,
		arg.ItemType,
		arg.ItemID,
		arg.Quantity,
		arg.ContainerInventoryID,
		arg.EquipmentSlotID,
		arg.Notes,
	)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemType,
		&i.ItemID,
		&i.Quantity,
		&i.ContainerInventoryID,
		&i.EquipmentSlotID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharacterInventory = `-- name: GetCharacterInventory :many
SELECT
    ci.id, ci.character_id, ci.item_type, ci.item_id, ci.quantity, ci.container_inventory_id, ci.equipment_slot_id, ci.notes, ci.created_at, ci.updated_at,
    es.name as slot_name,
    CASE ci.item_type
        WHEN 'equipment' THEN e.name
        WHEN 'weapon' THEN w.name
        WHEN 'armor' THEN a.name
        WHEN 'ammunition' THEN am.name
        WHEN 'container' THEN c.name
        WHEN 'shield' THEN s.name
        WHEN 'ranged_weapon' THEN rw.name
    END as item_name,
    CASE ci.item_type
        WHEN 'equipment' THEN e.weight
        WHEN 'weapon' THEN w.weight
        WHEN 'armor' THEN a.weight
        WHEN 'ammunition' THEN am.weight
        WHEN 'container' THEN c.weight
        WHEN 'shield' THEN s.weight
        WHEN 'ranged_weapon' THEN rw.weight
        ELSE 0
    END as item_weight
FROM
    character_inventory ci
    LEFT JOIN equipment_slots es ON ci.equipment_slot_id = es.id
    LEFT JOIN equipment e ON ci.item_type = 'equipment'
    AND ci.item_id = e.id
    LEFT JOIN weapons w ON ci.item_type = 'weapon'
    AND ci.item_id = w.id
    LEFT JOIN armor a ON ci.item_type = 'armor'
    AND ci.item_id = a.id
    LEFT JOIN ammunition am ON ci.item_type = 'ammunition'
    AND ci.item_id = am.id
    LEFT JOIN containers c ON ci.item_type = 'container'
    AND ci.item_id = c.id
    LEFT JOIN shields s ON ci.item_type = 'shield'
    AND ci.item_id = s.id
    LEFT JOIN ranged_weapons rw ON ci.item_type = 'ranged_weapon'
    AND ci.item_id = rw.id
WHERE
    ci.character_id = ?
ORDER BY
    ci.container_inventory_id NULLS FIRST,
    ci.equipment_slot_id NULLS LAST,
    item_name
`

type GetCharacterInventoryRow struct {
	ID                   int64          `json:"id"`
	CharacterID          int64          `json:"character_id"`
	ItemType             string         `json:"item_type"`
	ItemID               int64          `json:"item_id"`
	Quantity             int64          `json:"quantity"`
	ContainerInventoryID sql.NullInt64  `json:"container_inventory_id"`
	EquipmentSlotID      sql.NullInt64  `json:"equipment_slot_id"`
	Notes                sql.NullString `json:"notes"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	SlotName             sql.NullString `json:"slot_name"`
	ItemName             interface{}    `json:"item_name"`
	ItemWeight           int64          `json:"item_weight"`
}

func (q *Queries) GetCharacterInventory(ctx context.Context, characterID int64) ([]GetCharacterInventoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCharacterInventory, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCharacterInventoryRow
	for rows.Next() {
		var i GetCharacterInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.ItemType,
			&i.ItemID,
			&i.Quantity,
			&i.ContainerInventoryID,
			&i.EquipmentSlotID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SlotName,
			&i.ItemName,
			&i.ItemWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContainerContents = `-- name: GetContainerContents :many
SELECT
    ci.id, ci.character_id, ci.item_type, ci.item_id, ci.quantity, ci.container_inventory_id, ci.equipment_slot_id, ci.notes, ci.created_at, ci.updated_at,
    CASE ci.item_type
        WHEN 'equipment' THEN e.name
        WHEN 'weapon' THEN w.name
        WHEN 'armor' THEN a.name
        WHEN 'ammunition' THEN am.name
        WHEN 'container' THEN c.name
        WHEN 'shield' THEN s.name
        WHEN 'ranged_weapon' THEN rw.name
    END as item_name,
    CASE ci.item_type
        WHEN 'equipment' THEN e.weight
        WHEN 'weapon' THEN w.weight
        WHEN 'armor' THEN a.weight
        WHEN 'ammunition' THEN am.weight
        WHEN 'container' THEN c.weight
        WHEN 'shield' THEN s.weight
        WHEN 'ranged_weapon' THEN rw.weight
        ELSE 0
    END as item_weight
FROM
    character_inventory ci
    LEFT JOIN equipment e ON ci.item_type = 'equipment'
    AND ci.item_id = e.id
    LEFT JOIN weapons w ON ci.item_type = 'weapon'
    AND ci.item_id = w.id
    LEFT JOIN armor a ON ci.item_type = 'armor'
    AND ci.item_id = a.id
    LEFT JOIN ammunition am ON ci.item_type = 'ammunition'
    AND ci.item_id = am.id
    LEFT JOIN containers c ON ci.item_type = 'container'
    AND ci.item_id = c.id
    LEFT JOIN shields s ON ci.item_type = 'shield'
    AND ci.item_id = s.id
    LEFT JOIN ranged_weapons rw ON ci.item_type = 'ranged_weapon'
    AND ci.item_id = rw.id
WHERE
    ci.container_inventory_id = ?
    AND ci.character_id = ?
ORDER BY
    item_name
`

type GetContainerContentsParams struct {
	ContainerInventoryID sql.NullInt64 `json:"container_inventory_id"`
	CharacterID          int64         `json:"character_id"`
}

type GetContainerContentsRow struct {
	ID                   int64          `json:"id"`
	CharacterID          int64          `json:"character_id"`
	ItemType             string         `json:"item_type"`
	ItemID               int64          `json:"item_id"`
	Quantity             int64          `json:"quantity"`
	ContainerInventoryID sql.NullInt64  `json:"container_inventory_id"`
	EquipmentSlotID      sql.NullInt64  `json:"equipment_slot_id"`
	Notes                sql.NullString `json:"notes"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	ItemName             interface{}    `json:"item_name"`
	ItemWeight           int64          `json:"item_weight"`
}

func (q *Queries) GetContainerContents(ctx context.Context, arg GetContainerContentsParams) ([]GetContainerContentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContainerContents, arg.ContainerInventoryID, arg.CharacterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContainerContentsRow
	for rows.Next() {
		var i GetContainerContentsRow
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.ItemType,
			&i.ItemID,
			&i.Quantity,
			&i.ContainerInventoryID,
			&i.EquipmentSlotID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemName,
			&i.ItemWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEquippedItems = `-- name: GetEquippedItems :many
SELECT
    ci.id, ci.character_id, ci.item_type, ci.item_id, ci.quantity, ci.container_inventory_id, ci.equipment_slot_id, ci.notes, ci.created_at, ci.updated_at,
    es.name as slot_name,
    CASE ci.item_type
        WHEN 'equipment' THEN e.name
        WHEN 'weapon' THEN w.name
        WHEN 'armor' THEN a.name
        WHEN 'ammunition' THEN am.name
        WHEN 'container' THEN c.name
        WHEN 'shield' THEN s.name
        WHEN 'ranged_weapon' THEN rw.name
    END as item_name,
    CASE ci.item_type
        WHEN 'equipment' THEN e.weight
        WHEN 'weapon' THEN w.weight
        WHEN 'armor' THEN a.weight
        WHEN 'ammunition' THEN am.weight
        WHEN 'container' THEN c.weight
        WHEN 'shield' THEN s.weight
        WHEN 'ranged_weapon' THEN rw.weight
        ELSE 0
    END as item_weight
FROM
    character_inventory ci
    JOIN equipment_slots es ON ci.equipment_slot_id = es.id
    LEFT JOIN equipment e ON ci.item_type = 'equipment'
    AND ci.item_id = e.id
    LEFT JOIN weapons w ON ci.item_type = 'weapon'
    AND ci.item_id = w.id
    LEFT JOIN armor a ON ci.item_type = 'armor'
    AND ci.item_id = a.id
    LEFT JOIN ammunition am ON ci.item_type = 'ammunition'
    AND ci.item_id = am.id
    LEFT JOIN containers c ON ci.item_type = 'container'
    AND ci.item_id = c.id
    LEFT JOIN shields s ON ci.item_type = 'shield'
    AND ci.item_id = s.id
    LEFT JOIN ranged_weapons rw ON ci.item_type = 'ranged_weapon'
    AND ci.item_id = rw.id
WHERE
    ci.character_id = ?
    AND ci.equipment_slot_id IS NOT NULL
ORDER BY
    es.name
`

type GetEquippedItemsRow struct {
	ID                   int64          `json:"id"`
	CharacterID          int64          `json:"character_id"`
	ItemType             string         `json:"item_type"`
	ItemID               int64          `json:"item_id"`
	Quantity             int64          `json:"quantity"`
	ContainerInventoryID sql.NullInt64  `json:"container_inventory_id"`
	EquipmentSlotID      sql.NullInt64  `json:"equipment_slot_id"`
	Notes                sql.NullString `json:"notes"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	SlotName             string         `json:"slot_name"`
	ItemName             interface{}    `json:"item_name"`
	ItemWeight           int64          `json:"item_weight"`
}

func (q *Queries) GetEquippedItems(ctx context.Context, characterID int64) ([]GetEquippedItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEquippedItems, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEquippedItemsRow
	for rows.Next() {
		var i GetEquippedItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.ItemType,
			&i.ItemID,
			&i.Quantity,
			&i.ContainerInventoryID,
			&i.EquipmentSlotID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SlotName,
			&i.ItemName,
			&i.ItemWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemFromInventory = `-- name: GetItemFromInventory :one
SELECT
    id, character_id, item_type, item_id, quantity, container_inventory_id, equipment_slot_id, notes, created_at, updated_at
FROM
    character_inventory
WHERE
    id = ?
    AND character_id = ?
LIMIT
    1
`

type GetItemFromInventoryParams struct {
	ID          int64 `json:"id"`
	CharacterID int64 `json:"character_id"`
}

func (q *Queries) GetItemFromInventory(ctx context.Context, arg GetItemFromInventoryParams) (CharacterInventory, error) {
	row := q.db.QueryRowContext(ctx, getItemFromInventory, arg.ID, arg.CharacterID)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemType,
		&i.ItemID,
		&i.Quantity,
		&i.ContainerInventoryID,
		&i.EquipmentSlotID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeItemFromInventory = `-- name: RemoveItemFromInventory :exec
DELETE FROM character_inventory
WHERE
    id = ?
    AND character_id = ?
`

type RemoveItemFromInventoryParams struct {
	ID          int64 `json:"id"`
	CharacterID int64 `json:"character_id"`
}

func (q *Queries) RemoveItemFromInventory(ctx context.Context, arg RemoveItemFromInventoryParams) error {
	_, err := q.db.ExecContext(ctx, removeItemFromInventory, arg.ID, arg.CharacterID)
	return err
}

const updateInventoryItem = `-- name: UpdateInventoryItem :one
UPDATE character_inventory
SET
    quantity = ?,
    container_inventory_id = ?,
    equipment_slot_id = ?,
    notes = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = ?
    AND character_id = ? RETURNING id, character_id, item_type, item_id, quantity, container_inventory_id, equipment_slot_id, notes, created_at, updated_at
`

type UpdateInventoryItemParams struct {
	Quantity             int64          `json:"quantity"`
	ContainerInventoryID sql.NullInt64  `json:"container_inventory_id"`
	EquipmentSlotID      sql.NullInt64  `json:"equipment_slot_id"`
	Notes                sql.NullString `json:"notes"`
	ID                   int64          `json:"id"`
	CharacterID          int64          `json:"character_id"`
}

func (q *Queries) UpdateInventoryItem(ctx context.Context, arg UpdateInventoryItemParams) (CharacterInventory, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryItem,
		arg.Quantity,
		arg.ContainerInventoryID,
		arg.EquipmentSlotID,
		arg.Notes,
		arg.ID,
		arg.CharacterID,
	)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemType,
		&i.ItemID,
		&i.Quantity,
		&i.ContainerInventoryID,
		&i.EquipmentSlotID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
