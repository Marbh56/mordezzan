// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: spells.sql

package db

import (
	"context"
)

const addSpell = `-- name: AddSpell :one
INSERT INTO spells (
    name, description, range, duration
) VALUES (
    ?, ?, ?, ?
) RETURNING id, name, description, "range", duration, created_at, updated_at
`

type AddSpellParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Range       string `json:"range"`
	Duration    string `json:"duration"`
}

func (q *Queries) AddSpell(ctx context.Context, arg AddSpellParams) (Spell, error) {
	row := q.db.QueryRowContext(ctx, addSpell,
		arg.Name,
		arg.Description,
		arg.Range,
		arg.Duration,
	)
	var i Spell
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Range,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addSpellLevel = `-- name: AddSpellLevel :exec
INSERT INTO spell_levels (
    spell_id, class, level
) VALUES (
    ?, ?, ?
)
`

type AddSpellLevelParams struct {
	SpellID int64  `json:"spell_id"`
	Class   string `json:"class"`
	Level   int64  `json:"level"`
}

func (q *Queries) AddSpellLevel(ctx context.Context, arg AddSpellLevelParams) error {
	_, err := q.db.ExecContext(ctx, addSpellLevel, arg.SpellID, arg.Class, arg.Level)
	return err
}

const deleteSpell = `-- name: DeleteSpell :exec
DELETE FROM spells
WHERE id = ?
`

func (q *Queries) DeleteSpell(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSpell, id)
	return err
}

const deleteSpellLevels = `-- name: DeleteSpellLevels :exec
DELETE FROM spell_levels
WHERE spell_id = ?
`

func (q *Queries) DeleteSpellLevels(ctx context.Context, spellID int64) error {
	_, err := q.db.ExecContext(ctx, deleteSpellLevels, spellID)
	return err
}

const getSpellByID = `-- name: GetSpellByID :one
SELECT id, name, description, "range", duration, created_at, updated_at FROM spells WHERE id = ?
`

func (q *Queries) GetSpellByID(ctx context.Context, id int64) (Spell, error) {
	row := q.db.QueryRowContext(ctx, getSpellByID, id)
	var i Spell
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Range,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpellLevels = `-- name: GetSpellLevels :many
SELECT class, level
FROM spell_levels
WHERE spell_id = ?
ORDER BY class
`

type GetSpellLevelsRow struct {
	Class string `json:"class"`
	Level int64  `json:"level"`
}

func (q *Queries) GetSpellLevels(ctx context.Context, spellID int64) ([]GetSpellLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpellLevels, spellID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpellLevelsRow
	for rows.Next() {
		var i GetSpellLevelsRow
		if err := rows.Scan(&i.Class, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSpells = `-- name: ListAllSpells :many
SELECT id, name FROM spells ORDER BY name
`

type ListAllSpellsRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) ListAllSpells(ctx context.Context) ([]ListAllSpellsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllSpells)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllSpellsRow
	for rows.Next() {
		var i ListAllSpellsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpellsByClass = `-- name: ListSpellsByClass :many
SELECT 
    s.id, s.name, sl.level
FROM 
    spells s
JOIN 
    spell_levels sl ON s.id = sl.spell_id
WHERE 
    sl.class = ?
ORDER BY 
    sl.level, s.name
`

type ListSpellsByClassRow struct {
	ID    int64  `json:"id"`
	Name  string `json:"name"`
	Level int64  `json:"level"`
}

func (q *Queries) ListSpellsByClass(ctx context.Context, class string) ([]ListSpellsByClassRow, error) {
	rows, err := q.db.QueryContext(ctx, listSpellsByClass, class)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSpellsByClassRow
	for rows.Next() {
		var i ListSpellsByClassRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpellsByClassAndLevel = `-- name: ListSpellsByClassAndLevel :many
SELECT 
    s.id, s.name
FROM 
    spells s
JOIN 
    spell_levels sl ON s.id = sl.spell_id
WHERE 
    sl.class = ? AND sl.level = ?
ORDER BY 
    s.name
`

type ListSpellsByClassAndLevelParams struct {
	Class string `json:"class"`
	Level int64  `json:"level"`
}

type ListSpellsByClassAndLevelRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) ListSpellsByClassAndLevel(ctx context.Context, arg ListSpellsByClassAndLevelParams) ([]ListSpellsByClassAndLevelRow, error) {
	rows, err := q.db.QueryContext(ctx, listSpellsByClassAndLevel, arg.Class, arg.Level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSpellsByClassAndLevelRow
	for rows.Next() {
		var i ListSpellsByClassAndLevelRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpell = `-- name: UpdateSpell :one
UPDATE spells
SET 
    name = ?,
    description = ?,
    range = ?,
    duration = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE 
    id = ?
RETURNING id, name, description, "range", duration, created_at, updated_at
`

type UpdateSpellParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Range       string `json:"range"`
	Duration    string `json:"duration"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateSpell(ctx context.Context, arg UpdateSpellParams) (Spell, error) {
	row := q.db.QueryRowContext(ctx, updateSpell,
		arg.Name,
		arg.Description,
		arg.Range,
		arg.Duration,
		arg.ID,
	)
	var i Spell
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Range,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
